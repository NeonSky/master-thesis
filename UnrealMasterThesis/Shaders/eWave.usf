#include "/Engine/Public/Platform.ush"

static const float PI = 3.1415926535897933;
static const float gravity = 9.82;

struct Complex {
  float re;
  float im;
};

Complex newComplex(float re, float im) {
  Complex c;
  c.re = re;
  c.im = im;
  return c;
}

Complex mul(Complex c1, Complex c2) {
  Complex c;
  c.re = c1.re * c2.re - c1.im * c2.im;
  c.im = c1.re * c2.im + c1.im * c2.re;
  return c;
}

Complex add(Complex c1, Complex c2) {
  Complex c;
  c.re = c1.re + c2.re;
  c.im = c1.im + c2.im;
  return c;
}

int N;   // Resolution
float L; // Side length of patch in meters
float t; // Time (in seconds)

RWTexture2D<float4> eWave_h;
RWTexture2D<float4> eWave_hPrev;
RWTexture2D<float4> eWave_v;
RWTexture2D<float4> eWave_vPrev;

[numthreads(N_THREADS_X, N_THREADS_Y, 1)]
void eWaveCompute(uint3 id : SV_DispatchThreadID) {


  eWave_hPrev[id.xy] = eWave_h[id.xy];
  eWave_vPrev[id.xy] = eWave_v[id.xy];


  // Horizontal position
  // float2 x = float2(id.xy) - float(N) / 2.0;

  // Wave vector
  //float2 k_vec = float2(
  //  2.0 * PI * x.x / L,
  //  2.0 * PI * x.y / L
  //);

  //float2 k_vec = float2(
  //  x.x <= N_THREADS_X / 2 ? x.x * 1.0f : (N_THREADS_X - x.x) * 1.0f,
  //	x.y <= N_THREADS_Y / 2 ? x.y * 1.0f : (N_THREADS_Y - x.y) * 1.0f
  //);
  
  float2 k_vec = float2(
    id.x,
  	id.y
  );

  // Wave number
  float k = length(k_vec);
  k = max(k, 0.00001);

  float w = sqrt(gravity * k);

  float cos_w_t = cos(w * t);
  float sin_w_t = sin(w * t);

  float kOverw =  k / w;
  float gOverw = gravity / w;


  float h = cos_w_t * eWave_hPrev[id.xy] + kOverw * sin_w_t * eWave_vPrev[id.xy]; // eq 19
  Complex term1_19 = newComplex(eWave_hPrev[id.xy].x * cos_w_t, eWave_hPrev[id.xy].y * cos_w_t);                             // cos(wt) * h_prev
  Complex term2_19 = newComplex(eWave_vPrev[id.xy].x * sin_w_t * kOverw, eWave_vPrev[id.xy].y * sin_w_t * kOverw);           // |k|/w * sin(wt) * v_prev
  Complex height = add(term1_19, term2_19);


  float v = cos_w_t * eWave_vPrev[id.xy]      -      gOverw * sin_w_t * eWave_hPrev[id.xy]; // eq 20
  Complex term1_20 = newComplex(eWave_vPrev[id.xy].x * cos_w_t, eWave_vPrev[id.xy].y * cos_w_t);                             // cos(wt) * vprev
  Complex term2_20 = newComplex(eWave_hPrev[id.xy].x * sin_w_t * -1 * gOverw, eWave_hPrev[id.xy].y * sin_w_t * -1 * gOverw); // g/w * sin(wt) * h_prev * -1
  Complex velpot = add(term1_20, term2_20);

 
  

  eWave_h[id.xy] = float4(height.re, height.im, 0.0, 1.0); // Should I apply compex conj here?
  eWave_v[id.xy] = float4(velpot.re, velpot.im, 0.0, 1.0);

  //eWave_h[id.xy] = float4(eWave_h[id.xy].x, -eWave_h[id.xy].y, 0.0, 1.0); // complex conjugate on height to inverse FFT
  //eWave_v[id.xy] = float4(id.x, id.y, 0.0, 1.0);
  //eWave_hPrev[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
  //eWave_vPrev[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
  //eWave_h[id.xy] = eWave_h[id.xy];
  //eWave_v[id.xy] = eWave_v[id.xy];

}