#pragma once

static const float PI = 3.1415926535897933;
static const float M_TO_CM = 100.0;
static const float GRAVITY = 9.82;
static const float DENSITY_OF_WATER = 1000.0;
static const float HORSEPOWER_TO_NEWTON = 750.0;

/* Complex number stuff */

struct Complex {
  float re;
  float im;
};

Complex newComplex(float re, float im) {
  Complex c;
  c.re = re;
  c.im = im;
  return c;
}

Complex mul(Complex c1, Complex c2) {
  Complex c;
  c.re = c1.re * c2.re - c1.im * c2.im;
  c.im = c1.re * c2.im + c1.im * c2.re;
  return c;
}

Complex add(Complex c1, Complex c2) {
  Complex c;
  c.re = c1.re + c2.re;
  c.im = c1.im + c2.im;
  return c;
}

Complex conj(Complex c) {
  c.im = -c.im;
  return c;
}

/* Quaternion stuff */

float4 qmul(float4 q1, float4 q2) {
    return float4(
        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
    );
}

float3 rotate_vector_by_quat(float3 v, float4 q) {
    float4 q_conj = q * float4(-1, -1, -1, 1);
    return qmul(q, qmul(float4(v, 0), q_conj)).xyz;
}

/* Rigidbody stuff */

struct Rigidbody {
    float3 force;
    float3 linear_velocity;
    float3 position;

    float3 torque;
    float3 angular_velocity;
    float4 orientation;

    float mass;
    float moment_of_inertia;
};

void add_force_at_position(inout Rigidbody rigidbody, float3 f, float3 pos) {
    pos -= rigidbody.position;

    rigidbody.force += f;

    if (length(pos) > 0.0001) {
        rigidbody.torque += cross(pos, f);
    }
}

void update_rigidbody(inout Rigidbody rigidbody) {

    const float dt = 0.02;

    float3 linear_acceleration = rigidbody.force / rigidbody.mass;
    rigidbody.linear_velocity += linear_acceleration * dt;
    rigidbody.position        += rigidbody.linear_velocity * dt;

    float3 angular_acceleration = rigidbody.torque / rigidbody.moment_of_inertia;
    rigidbody.angular_velocity += angular_acceleration * dt;

    // Angular velocity orientation
    float3 v = 0.5 * rigidbody.angular_velocity * dt;
    float4 avo = float4(v, 0.0);

    rigidbody.orientation = normalize(rigidbody.orientation + qmul(avo, rigidbody.orientation));
}

/* Ocean stuff */

float sample_elevation(Texture2D<float4> elevation_texture, float2 ws_coord) {

    const float L = 100.0;
    const float world_size = M_TO_CM * L;

    // The coordinate of interest in normalized UV space.
    float2 coord = (world_size * 0.5 + ws_coord) / world_size;

    SamplerState Sampler {
        Filter = MIN_MAG_MIP_LINEAR;
        AddressU = Wrap;
        AddressV = Wrap;
    };
    float elevation = elevation_texture.SampleLevel(Sampler, coord, 0).r;

    return elevation;
}