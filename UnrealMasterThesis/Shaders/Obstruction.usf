#include "/Engine/Public/Platform.ush"

#include "Common.ush"

Texture2D<float4> BoatTexture;
StructuredBuffer<SubmergedTriangle> SubmergedTrianglesBuffer;

RWTexture2D<float4> obstructionMap_rtt;
RWTexture2D<float4> hv_rtt;
RWTexture2D<float4> hv_prev_rtt;
int preFFT; 


float T(float x_y){
	float L_in_pixels = 256.0; // TODO: make these in parameters to the shader
	float taper_size = 8.0;
	if(x_y / taper_size < 1.0){
		return x_y / taper_size;
	}
	else if(abs(x_y - L_in_pixels) / taper_size < 1.0){
		return abs(x_y - L_in_pixels) / taper_size;
	}
	else{
		return 1.0;
	}
}

float remap(float x, float in_min, float in_max, float out_min, float out_max){
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

bool ptInTriangle(float4 p, float4 p0, float4 p1, float4 p2){
    float A = 1.0 / 2.0 * (-p1[1] * p2[0] + p0[1] * (-p1[0] + p2[0]) + p0[0] * (p1[1] - p2[1]) + p1[0] * p2[1]);
    float tsign = (A < 0.0) ? -1.0 : 1.0;
    float s = (p0[1] * p2[0] - p0[0] * p2[1] + (p2[1] - p0[1]) * p[0] + (p0[0] - p2[0]) * p[1]) * tsign;
    float t = (p0[0] * p1[1] - p0[1] * p1[0] + (p0[1] - p1[1]) * p[0] + (p1[0] - p0[0]) * p[1]) * tsign;

	float epsilon = 0.001; // Note: without + epsilon we get false positives from this test...
    return s > epsilon && t > epsilon && (s + t) < ((2.0 * A * tsign) - epsilon);
}

[numthreads(N_THREADS_X, N_THREADS_Y, 1)]
void eWaveCompute(uint3 id : SV_DispatchThreadID) {
	float hTEST = 0.0;

	float cm_per_pixel = L * M_TO_CM / N;

	float3 vel = BoatTexture[uint2(2,0)].rgb; // RGB of (2,0) stores velocity
	float speedScale = pow(length(vel), 1.5) / 500.0;

	float2 pos = BoatTexture[uint2(0,0)].rg; // RG of (0,0) stores horizontal position (see gravity in GPUBoat.usf)
	int xp = (pos.x * M_TO_CM) / cm_per_pixel;
	int yp = (pos.y * M_TO_CM) / cm_per_pixel;

	float2 prev_pos = BoatTexture[uint2(0,1)].rg; // RG of (0,1) stores previous horizontal position
	int prev_xp = (prev_pos.x * M_TO_CM) / cm_per_pixel;
	int prev_yp = (prev_pos.y * M_TO_CM) / cm_per_pixel;

	int boat_dx = xp - prev_xp;
	int boat_dy = yp - prev_yp;

	pos.x = xp * cm_per_pixel / M_TO_CM;
	pos.y = yp * cm_per_pixel / M_TO_CM;
	
	// ----------------------------------------------------------------------------------
	// Pre processing steps:
	// 		sample the previous frames height and velocity potential fields from copies.
	// 		compute the obstruction map from the submerged triangles.
	// ----------------------------------------------------------------------------------
	
	int2 sampleCoordinates = int2(id.x, id.y);
	if (preFFT >= 1) {
		// Offset when sampling from prev textures to move the simulation.
		sampleCoordinates = int2(id.x + boat_dx, id.y + boat_dy);
	}
	
	if (preFFT == 2) {
		// Compute the obstruction map
		// it should be 0.0 where the boats submerged triangles are. Rest should be 1.0
		float half_L_in_metres = 50.0f;
		float oldMinX = pos.x - half_L_in_metres; // TODO: replace 0 with offset to move with the boat.
		float oldMaxX = pos.x + half_L_in_metres;
		float oldMinY = pos.y - half_L_in_metres;
		float oldMaxY = pos.y + half_L_in_metres;
		obstructionMap_rtt[sampleCoordinates.xy] = float4(1.0, 0.0, 0.0, 1.0);

		for (int i = 0; i < N_TRIANGLES; i++) {

			SubmergedTriangle t = SubmergedTrianglesBuffer[i];
			if (t.center_and_area.w <= 0.0) {
				continue;
			}

			float4 v1 = t.v1;
			v1.x = remap(v1.x, oldMinX, oldMaxX, 0, N);
			v1.y = remap(v1.y, oldMinY, oldMaxY, 0, N);

			float4 v2 = t.v2;
			v2.x = remap(v2.x, oldMinX, oldMaxX, 0, N);
			v2.y = remap(v2.y, oldMinY, oldMaxY, 0, N); 

			float4 v3 = t.v3;
			v3.x = remap(v3.x, oldMinX, oldMaxX, 0, N);
			v3.y = remap(v3.y, oldMinY, oldMaxY, 0, N); // we can ignore z
			
			// TODO: ?
			if(ptInTriangle(float4(sampleCoordinates.xy, 0.0, 1.0), v1, v2, v3)){
				obstructionMap_rtt[sampleCoordinates.xy] = float4(0.0, 0.0, 0.0, 1.0);
			}
		}

		hv_prev_rtt[id.xy] = hv_rtt[id.xy];

		return;

	}

	float2 hv = hv_prev_rtt[sampleCoordinates.xy].rg;
	float h = hv.x;
	float v = hv.y;

	// ----------------------------------------------------------------------------------
	// Step 1, Apply obstruction:
	// ----------------------------------------------------------------------------------
	h *= obstructionMap_rtt[id.xy].r;
	
	// ----------------------------------------------------------------------------------
	// Step 2, Apply ambient waves: (TODO: the entire step)
	//		Note: this should only be done before FFT
	// ----------------------------------------------------------------------------------
	//if(preFFT == 1){
	//	
		
	//}
	
	// ----------------------------------------------------------------------------------
	// Step 3, Apply trim (boundary conditions)
	// ----------------------------------------------------------------------------------
	float T_x = T(id.x);
	float T_y = T(id.y);
	h = h * T_x * T_y;
	v = v * T_x * T_y;
	
	
	// ----------------------------------------------------------------------------------
	// Step 4, Add sources
	//		Note: this should only be done before FFT
	// ----------------------------------------------------------------------------------
	if (preFFT == 1) {
		float scale = 5.0 * speedScale; // Needs to match material
		float obsCompliment = 1.0 - obstructionMap_rtt[id.xy].r;
		h += scale * obsCompliment;
	}
	
	
	// ----------------------------------------------------------------------------------
	// Write results.
	// ----------------------------------------------------------------------------------
	// As a last step, make sure that when the simulation moved it leaves 0s behind.
	if(    (sampleCoordinates.x >= 0 && sampleCoordinates.x <= 255) 
		&& (sampleCoordinates.y >= 0 && sampleCoordinates.y <= 255)){
		h = h;
		v = v;	
	}
	else{
		h = 0.0;
		v = 0.0;
	}
	if (preFFT > 0) {
		hTEST = 0.0123456;
	}
	else{
		hTEST = h;
	}
	 
	//hv_rtt[id.xy] = float4(h, v, pos.x * M_TO_CM, pos.y * M_TO_CM);
	hv_rtt[id.xy] = float4(hTEST, v, pos.x * M_TO_CM, pos.y * M_TO_CM);
}