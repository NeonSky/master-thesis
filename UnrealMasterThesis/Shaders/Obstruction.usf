#include "/Engine/Public/Platform.ush"

StructuredBuffer<float4> submergedTriangleVertices;
int numTriangles;
int L;

RWTexture2D<float4> obstructionMap_rtt;
RWTexture2D<float4> h_rtt;
RWTexture2D<float4> v_rtt;
RWTexture2D<float4> hPrev_rtt;
RWTexture2D<float4> vPrev_rtt;
float xPos;
float yPos;
int offset_x;
int offset_y;


float T(float x_y){
	float L_in_pixels = 256.0; // TODO: make these in parameters to the shader
	float taper_size = 32.0;
	if(x_y / taper_size < 1.0){
		return x_y / taper_size;
	}
	else if(abs(x_y - L_in_pixels) / taper_size < 1.0){
		return abs(x_y - L_in_pixels) / taper_size;
	}
	else{
		return 1.0;
	}
}

float remap(float x, float in_min, float in_max, float out_min, float out_max){
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

bool ptInTriangle(float4 p, float4 p0, float4 p1, float4 p2){
    float A = 1.0 / 2.0 * (-p1[1] * p2[0] + p0[1] * (-p1[0] + p2[0]) + p0[0] * (p1[1] - p2[1]) + p1[0] * p2[1]);
    float tsign = (A < 0.0) ? -1.0 : 1.0;
    float s = (p0[1] * p2[0] - p0[0] * p2[1] + (p2[1] - p0[1]) * p[0] + (p0[0] - p2[0]) * p[1]) * tsign;
    float t = (p0[0] * p1[1] - p0[1] * p1[0] + (p0[1] - p1[1]) * p[0] + (p1[0] - p0[0]) * p[1]) * tsign;

    return s > 0.0 && t > 0.0 && (s + t) < 2.0 * A * tsign;
}

[numthreads(N_THREADS_X, N_THREADS_Y, 1)]
void eWaveCompute(uint3 id : SV_DispatchThreadID) {
	
	// ----------------------------------------------------------------------------------
	// Pre processing steps:
	// 		sample the previous frames height and velocity potential fields from copies.
	// 		compute the obstruction map from the submerged triangles.
	// ----------------------------------------------------------------------------------
	// TODO: offset when sampling from prev textures to move the simulation.
	float h = hPrev_rtt[id.xy].r;
	float v = vPrev_rtt[id.xy].r;
	int preFFT = offset_y;
	
	
	// Compute the obstruction map
	// it should be 0.0 where the boats submerged triangles are. Rest should be 1.0
	float half_L_in_metres = 50.0f;
	float oldMinX = 0 - half_L_in_metres; // TODO: replace 0 with offset to move with the boat.
	float oldMaxX = 0 + half_L_in_metres;
	float oldMinY = 0 - half_L_in_metres;
	float oldMaxY = 0 + half_L_in_metres;
	int N = 256;
	obstructionMap_rtt[id.xy] = float4(1.0, 0.0, 0.0, 1.0);
	for(int i = 0; i < (numTriangles * 3); i+=3){
		float4 v0 = submergedTriangleVertices[i + 0];
		v0.x = remap(v0.x, oldMinX, oldMaxX, 0, N);
		v0.y = remap(v0.y, oldMinY, oldMaxY, 0, N);
		float4 v1 = submergedTriangleVertices[i + 1];
		v1.x = remap(v1.x, oldMinX, oldMaxX, 0, N);
		v1.y = remap(v1.y, oldMinY, oldMaxY, 0, N); 
		float4 v2 = submergedTriangleVertices[i + 2];
		v2.x = remap(v2.x, oldMinX, oldMaxX, 0, N);
		v2.y = remap(v2.y, oldMinY, oldMaxY, 0, N); // we can ignore z
		
		if(ptInTriangle(float4(id.x, id.y, 0.0, 1.0), v0, v1, v2)){
			obstructionMap_rtt[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
		}	
	}
	// ----------------------------------------------------------------------------------
	// Step 1, Apply obstruction:
	// ----------------------------------------------------------------------------------
	h *= obstructionMap_rtt[id.xy].r;
	
	// ----------------------------------------------------------------------------------
	// Step 2, Apply ambient waves: (TODO: the entire step)
	//		Note: this should only be done before FFT
	// ----------------------------------------------------------------------------------
	//if(preFFT == 1){
	//	
		
	//}
	
	// ----------------------------------------------------------------------------------
	// Step 3, Apply trim (boundary ocnditions)
	// ----------------------------------------------------------------------------------
	float T_x = T(id.x);
	float T_y = T(id.y);
	h = h * T_x * T_y;
	v = v * T_x * T_y;
	
	
	// ----------------------------------------------------------------------------------
	// Step 4, Add sources
	//		Note: this should only be done before FFT
	// ----------------------------------------------------------------------------------
	if(preFFT == 1){
		int speedScaleFactor = offset_x;
		float scale = 0.65 * speedScaleFactor;
		float obsCompliment = 1.0 - obstructionMap_rtt[id.xy];
		h += scale * obsCompliment;
	}
	
	
	// ----------------------------------------------------------------------------------
	// Write results.
	// ----------------------------------------------------------------------------------
	// TODO: as a last step, make sure that when the simulation moved it leaves 0s behind.
	
	h_rtt[id.xy] = float4(h, 0.0, 0.0, 1.0);
	v_rtt[id.xy] = float4(v, 0.0, xPos, yPos);
}