#include "/Engine/Public/Platform.ush"

#include "Common.ush"

float SpeedInput;
float2 VelocityInput;
Texture2D<float4> ElevationTexture;
RWTexture2D<float4> InputOutputTexture;

Rigidbody get_rigidbody() {
    Rigidbody rigidbody;

    rigidbody.force  = float3(0.0, 0.0, 0.0);
    rigidbody.torque = float3(0.0, 0.0, 0.0);

    rigidbody.position    = InputOutputTexture[uint2(0,0)].rgb; // RGB of (0,0) stores position
    rigidbody.orientation = InputOutputTexture[uint2(1,0)]; // RGBA of (1,0) stores orientation

    rigidbody.linear_velocity  = InputOutputTexture[uint2(2,0)].rgb; // RGB of (2,0) stores linear velocity
    rigidbody.angular_velocity = InputOutputTexture[uint2(3,0)].rgb; // RGB of (3,0) stores angular velocity

    rigidbody.mass              = 2000.0;
    rigidbody.moment_of_inertia = 100.0 * rigidbody.mass;

    return rigidbody;
}

void apply_gravity(inout Rigidbody rigidbody) {
    float3 gravity_force = GRAVITY * rigidbody.mass * float3(0.0, 0.0, -1.0);
    add_force_at_position(rigidbody, gravity_force, rigidbody.position);
}

void apply_buoyancy(inout Rigidbody rigidbody) {

    float elevation = sample_elevation(ElevationTexture, rigidbody.position.xy * M_TO_CM) / M_TO_CM;
    float height = rigidbody.position.y - elevation;

    if (height < 0.0) {
        height = -height;
        float area = 27.045519; // manually copied from CPU
        float3 buoyancy_force = DENSITY_OF_WATER * GRAVITY * height * area * float3(0.0, 0.0, 1.0);
        add_force_at_position(rigidbody, buoyancy_force, rigidbody.position);
        // rigidbody.position += height;
        // rigidbody.force = float3(0.0, 0.0, 0.0);
    }
}

void apply_user_input(inout Rigidbody rigidbody) {

    // TODO: transform these
    float3 forward = rotate_vector_by_quat(float3(1.0, 0.0, 0.0), rigidbody.orientation);
    float3 right   = rotate_vector_by_quat(float3(0.0, 1.0, 0.0), rigidbody.orientation);

    if (VelocityInput.y > 0.0) {
        float3 engine_pos = float3(-210.0, 0.0, -30.0) / M_TO_CM;

        // TODO: transform (i.e. also rotate) engine_pos
        engine_pos += rigidbody.position;

        float engine_power = HORSEPOWER_TO_NEWTON * SpeedInput;

        // add_force_at_position(rigidbody, engine_power * VelocityInput.y * forward, engine_pos);
        add_force_at_position(rigidbody, engine_power * VelocityInput.y * forward, rigidbody.position);
    }

    float3 steer_pos = rigidbody.position + 100.0f * forward;
    float engine_power = HORSEPOWER_TO_NEWTON * sqrt(SpeedInput); // Nerf sideways movement

    add_force_at_position(rigidbody, engine_power * VelocityInput.x * right, steer_pos);
    // add_force_at_position(rigidbody, engine_power * VelocityInput.x * right, rigidbody.position);
}

void apply_resistance_forces(inout Rigidbody rigidbody) {

    const float c_damp = 500.0;
    const float angular_drag = 0.1;

    float r_s = 0.2; // TODO

    // add_force_at_position(rigidbody, engine_power * VelocityInput.x * right, steer_pos);

    // Linear damping of linear velocity
    add_force_at_position(rigidbody, -c_damp * r_s * rigidbody.linear_velocity, rigidbody.position);

    // Quadratic damping of linear velocity
    add_force_at_position(rigidbody, -c_damp * r_s * rigidbody.linear_velocity * length(rigidbody.linear_velocity), rigidbody.position);

    // Damping of angular velocity
    rigidbody.angular_velocity -= angular_drag * rigidbody.angular_velocity * (1.0f - r_s);
}

[numthreads(N_THREADS_X, N_THREADS_Y, 1)]
void MainCompute(uint3 id : SV_DispatchThreadID) {

    Rigidbody rigidbody = get_rigidbody();

    // Debug: reset
    // rigidbody.position = float3(5.0, 0.0, 0.0);
    // rigidbody.orientation = float4(0.0, 0.0, 0.0, 1.0);
    // rigidbody.linear_velocity = float3(0.0, 0.0, 0.0);
    // rigidbody.angular_velocity = float3(0.0, 0.0, 0.0);

    // apply_gravity(rigidbody);
    // apply_buoyancy(rigidbody);
    apply_resistance_forces(rigidbody);
    apply_user_input(rigidbody);

    update_rigidbody(rigidbody);

    // Debug
    // InputOutputTexture[uint2(4,0)].rgb = M_TO_CM * rigidbody.linear_velocity;
    InputOutputTexture[uint2(4,0)] = rigidbody.orientation;
    // InputOutputTexture[uint2(4,0)].rgb = rigidbody.angular_velocity;

    // Store results
    InputOutputTexture[uint2(0,0)].rgb = rigidbody.position;
    InputOutputTexture[uint2(1,0)]     = rigidbody.orientation;
    InputOutputTexture[uint2(2,0)].rgb = rigidbody.linear_velocity;
    InputOutputTexture[uint2(3,0)].rgb = rigidbody.angular_velocity;

}