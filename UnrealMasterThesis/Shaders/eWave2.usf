#include "/Engine/Public/Platform.ush"

static const float PI = 3.1415926535897933;
static const float gravity = 9.82;

int N;   // Resolution
float L; // Side length of patch in meters
float t; // Time (in seconds)
int offsetSign_x;
int offsetSign_y;

RWTexture2D<float4> eWave_h;
RWTexture2D<float4> eWave_hPrev;
RWTexture2D<float4> eWave_v;
RWTexture2D<float4> eWave_vPrev;

[numthreads(N_THREADS_X, N_THREADS_Y, 1)]
void eWaveCompute(uint3 id : SV_DispatchThreadID) {

	// TODO: rewrite logic... we should not need so many If/Else

	//eWave_hPrev[id.xy] = eWave_h[id.xy];
	//eWave_vPrev[id.xy] = eWave_v[id.xy];
	float4 hPrev = eWave_h[id.xy];
	float4 vPrev = eWave_v[id.xy];

	float LL = L;
	LL = 100.0f;
	float dkx = 2 * PI / LL;
	float dky = dkx;


	float kx, ky;

	if (id.x <= N / 2.0)
		kx = id.x*dkx;
	else
		kx = (N - id.x)*dkx;

	if (id.y <= N / 2.0)
		ky = id.y*dky;
	else
		ky = (N - id.y)*dky;

	float m_k = sqrt(kx*kx + ky*ky);
	float w = sqrt(gravity*m_k);

	float coswk = cos(w*t);
	float sinwk = sin(w*t);


	int2 offID = int2(id.x + offsetSign_x * 128, id.y + offsetSign_y * 128);
	if (m_k != 0)
	{
		float hRe = coswk*hPrev.r + (m_k / w)*sinwk*vPrev.r; // eq 19
		float hIm = coswk*hPrev.g + (m_k / w)*sinwk*vPrev.g; // eq 19

		float vRe = coswk*vPrev.r - (gravity / w)*sinwk*hPrev.r; // eq 20	
		float vIm = coswk*vPrev.g - (gravity / w)*sinwk*hPrev.g; // eq 20
		
		eWave_h[id.xy] = float4(hRe, hIm, 0.0, 1.0);
		eWave_v[id.xy] = float4(vRe, vIm, 0.0, 1.0);
		
	}
	else{
		eWave_h[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
		eWave_v[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
	}



}