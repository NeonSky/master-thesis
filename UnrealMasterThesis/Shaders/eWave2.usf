#include "/Engine/Public/Platform.ush"

static const float PI = 3.1415926535897933;
static const float gravity = 9.82;

int N;   // Resolution
float L; // Side length of patch in meters
float t; // Time (in seconds)
int offsetSign_x;
int offsetSign_y;

RWTexture2D<float4> eWave_h;
RWTexture2D<float4> eWave_hPrev;
RWTexture2D<float4> eWave_v;
RWTexture2D<float4> eWave_vPrev;

[numthreads(N_THREADS_X, N_THREADS_Y, 1)]
void eWaveCompute(uint3 id : SV_DispatchThreadID) {

	// TODO: rewrite logic... we should not need so many If/Else

	eWave_hPrev[id.xy] = eWave_h[id.xy];
	eWave_vPrev[id.xy] = eWave_v[id.xy];

	float LL = L;
	LL = 1.0f;
	float dkx = 2 * PI / LL;
	float dky = dkx;


	float kx, ky;

	if (id.x <= N / 2.0)
		kx = id.x*dkx;
	else
		kx = (N - id.x)*dkx;

	if (id.y <= N / 2.0)
		ky = id.y*dky;
	else
		ky = (N - id.y)*dky;

	float m_k = sqrt(kx*kx + ky*ky);
	float w = sqrt(gravity*m_k);

	float coswk = cos(w*t);
	float sinwk = sin(w*t);


	int2 offID = int2(id.x + offsetSign_x * 85, id.y + offsetSign_y * 85);
	if (m_k != 0)
	{
		float hRe = coswk*eWave_hPrev[offID.xy].r + (m_k / w)*sinwk*eWave_vPrev[offID.xy].r; // eq 19
		float hIm = coswk*eWave_hPrev[offID.xy].g + (m_k / w)*sinwk*eWave_vPrev[offID.xy].g; // eq 19

		float vRe = coswk*eWave_vPrev[offID.xy].r - (gravity / w)*sinwk*eWave_hPrev[offID.xy].r; // eq 20	
		float vIm = coswk*eWave_vPrev[offID.xy].g - (gravity / w)*sinwk*eWave_hPrev[offID.xy].g; // eq 20
		
		eWave_h[id.xy] = float4(hRe, hIm, 0.0, 1.0);
		eWave_v[id.xy] = float4(vRe, vIm, 0.0, 1.0);
		
	}
	else{
		eWave_h[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
		eWave_v[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
	}



}